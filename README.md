# ImageMatching

## 1. 특징점 추출

### 1-1. 특징 벡터
- 실수 특징 벡터 
>> L2 노름(L2 Norm) 사용
>> numpy.float32 자료형, 실수 정보를 저장
>> SIFT, SURF, KAZE 등이 있음
>> RGB 값의 기울기 이용해, 방향 성분으로 영상의 특징을 기술

- 이진 특징 벡터 
>> 해밍 거리(Hamming Distance) 사용
>> numpy.uint8 자료형, 비트 단위로 저장
>> AKAZE, ORB, BRIEF 등이 있음
>> RGB의 차이 값들을 이진수로 표현
>> ex) 1번과 2번 중 1번이 더 밝으면 1로 기술

### 1-2. 연산 속도 비교 
![다운로드](https://github.com/mb5ss95/ImageMatching/assets/60500325/fa8f9380-0680-4f94-8ec7-255228f9403b)

- ORB는 매칭 퀄리티, 검출 결과가 별로지만 속도가 빠름(엣지 디바이스에 어울릴듯...!!)
- 매칭 성능은 SHIFT가 가장 좋지만 연산 시간이 제일 느림


## 2. 특징점 매칭
- 두 이미지에서 추출한 특징점을 비교하여 서로 유사한 것을 찾는 작업임.
- 알고리즘이 가장 근접한 점을 찾아 매칭 되는 경우 필터링하는 작업이 필요함.

### 2-1. 특징 벡터 방법
- 실수 특징 벡터 >> L2 노름(L2 Norm) 사용
- 이진 특징 벡터 >> 해밍 거리(Hamming Distance) 사용

### 2-2. OpenCV 특징점 매칭 클래스
- match >> 가장 비슷한거 1개를 매칭
- knnMatch >> 비슷한거 k개를 매칭
- radiusMatch >> 반경을 정해두고, 반경에 들어오는 것들을 매칭
- 위 세 가지를 상속 받은 BFMatcher, FlannBasedMatcher를 이용해야 함.
- BFMatcher >> 전수 조사함, 특징점이 많으면 시간이 걸림
- FlannMatcher >> 근사화하여 조사함, 완전한 최소값에 매칭하지 못할수도 있지만, 속도가 빠름. 내부적으로 KD트리를 이용함.

### 2-3. 좋은 매칭을 선별하는 방법(정렬, 임계값 이용)
- 정렬 >> 거리 기준으로 정렬 후 상위 N개 선택
- 임계값 이용 >> 가장 좋은 매칭과 두번째로 좋은 매칭 값의 비율을 임계값으로 설정하여 선별

